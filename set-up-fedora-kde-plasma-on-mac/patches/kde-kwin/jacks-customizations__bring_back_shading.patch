From: Jacks Diao <kdha200501@gmail.com>
Subject: [PATCH] jacks-customizations: bring back shading
---
Index: src/decorations/decoratedwindow.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/decorations/decoratedwindow.cpp b/src/decorations/decoratedwindow.cpp
--- a/src/decorations/decoratedwindow.cpp	(revision 9739e3174abaaa97a3008f6933af4642bc26b800)
+++ b/src/decorations/decoratedwindow.cpp	(revision f9fae66c0b4be8f6ca8f383fcd823190d7dd0143)
@@ -170,7 +170,8 @@

 void DecoratedWindowImpl::requestMinimize()
 {
-    m_window->setMinimized(true);
+    // leach off the maximization mechanism to perform shading when the "minimize" window CTA is clicked
+    delayedRequestToggleMaximization(Options::ShadeOp);
 }

 void DecoratedWindowImpl::requestClose()
Index: src/effect/globals.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/effect/globals.h b/src/effect/globals.h
--- a/src/effect/globals.h	(revision 9739e3174abaaa97a3008f6933af4642bc26b800)
+++ b/src/effect/globals.h	(revision f9fae66c0b4be8f6ca8f383fcd823190d7dd0143)
@@ -59,6 +59,7 @@
     MaximizeHorizontal = 2, ///< The window is maximized horizontally.
     /// Equal to @p MaximizeVertical | @p MaximizeHorizontal
     MaximizeFull = MaximizeVertical | MaximizeHorizontal,
+    MaximizeShade = 1027,
 };
 Q_ENUM_NS(MaximizeMode)

Index: src/useractions.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/useractions.cpp b/src/useractions.cpp
--- a/src/useractions.cpp	(revision 9739e3174abaaa97a3008f6933af4642bc26b800)
+++ b/src/useractions.cpp	(revision f9fae66c0b4be8f6ca8f383fcd823190d7dd0143)
@@ -897,7 +897,7 @@
     initShortcut("Window Minimize", i18n("Minimize Window"),
                  Qt::META | Qt::Key_PageDown, &Workspace::slotWindowMinimize);
     initShortcut("Window Shade", i18n("Shade Window"),
-                 0, &Workspace::slotWindowShade);
+                 Qt::CTRL | Qt::Key_M, &Workspace::slotWindowShade);
     initShortcut("Window Move", i18n("Move Window"),
                  0, &Workspace::slotWindowMove);
     initShortcut("Window Resize", i18n("Resize Window"),
@@ -1175,7 +1175,11 @@
         window->setMinimized(true);
         break;
     case Options::ShadeOp:
-        window->performMousePressCommand(Options::MouseShade, Cursors::self()->mouse()->pos());
+        // leach off the maximization mechanism to perform shading when the "Ctrl + M" combo is pressed
+        window->maximize(window->maximizeMode() == MaximizeShade
+                                     ? MaximizeRestore
+                                     : MaximizeShade);
+        takeActivity(window, ActivityFocus | ActivityRaise);
         break;
     case Options::OnAllDesktopsOp:
         window->setOnAllDesktops(!window->isOnAllDesktops());
Index: src/wayland/xdgshell.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/wayland/xdgshell.h b/src/wayland/xdgshell.h
--- a/src/wayland/xdgshell.h	(revision 9739e3174abaaa97a3008f6933af4642bc26b800)
+++ b/src/wayland/xdgshell.h	(revision f9fae66c0b4be8f6ca8f383fcd823190d7dd0143)
@@ -214,8 +214,8 @@

 public:
     enum State {
-        MaximizedHorizontal = 0x1,
-        MaximizedVertical = 0x2,
+        MaximizedHorizontal = 0x1,//                           000000000001 in practice, kwin treats this flag as size-changed-horizontally
+        MaximizedVertical = 0x2,//                             000000000010 in practice, kwin treats this flag as size-changed-vertically
         FullScreen = 0x4,
         Resizing = 0x8,
         Activated = 0x10,
@@ -224,7 +224,8 @@
         TiledRight = 0x80,
         TiledBottom = 0x100,
         Suspended = 0x200,
-        Maximized = MaximizedHorizontal | MaximizedVertical,
+        Maximized = MaximizedHorizontal | MaximizedVertical,// 000000000011
+        Shaded = 0x403,//                                      010000000011
     };
     Q_DECLARE_FLAGS(States, State)

Index: src/x11window.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/x11window.cpp b/src/x11window.cpp
--- a/src/x11window.cpp	(revision 9739e3174abaaa97a3008f6933af4642bc26b800)
+++ b/src/x11window.cpp	(revision f9fae66c0b4be8f6ca8f383fcd823190d7dd0143)
@@ -3986,7 +3986,7 @@
 }

 static bool changeMaximizeRecursion = false;
-void X11Window::maximize(MaximizeMode mode, const QRectF &restore)
+void X11Window::maximize(MaximizeMode nextMaximizeMode, const QRectF &restore)
 {
     if (isUnmanaged()) {
         qCWarning(KWIN_CORE) << "Cannot change maximized state of unmanaged window" << this;
@@ -3997,7 +3997,7 @@
         return;
     }

-    if (!isMaximizable() && mode != MaximizeRestore) {
+    if (!isMaximizable() && nextMaximizeMode != MaximizeRestore) {
         return;
     }

@@ -4008,10 +4008,13 @@
         clientArea = workspace()->clientArea(MaximizeArea, this, moveResizeOutput());
     }

-    MaximizeMode old_mode = max_mode;
+    MaximizeMode currentMaximizeMode = max_mode;

-    mode = rules()->checkMaximize(mode);
-    if (max_mode == mode) {
+    if (nextMaximizeMode != MaximizeShade) {
+        nextMaximizeMode = rules()->checkMaximize(nextMaximizeMode);
+    }
+
+    if (currentMaximizeMode == nextMaximizeMode) {
         return;
     }

@@ -4019,13 +4022,13 @@

     // maximing one way and unmaximizing the other way shouldn't happen,
     // so restore first and then maximize the other way
-    if ((old_mode == MaximizeVertical && mode == MaximizeHorizontal)
-        || (old_mode == MaximizeHorizontal && mode == MaximizeVertical)) {
+    if ((currentMaximizeMode == MaximizeVertical && nextMaximizeMode == MaximizeHorizontal)
+        || (currentMaximizeMode == MaximizeHorizontal && nextMaximizeMode == MaximizeVertical)) {
         maximize(MaximizeRestore); // restore
     }

-    Q_EMIT maximizedAboutToChange(mode);
-    max_mode = mode;
+    Q_EMIT maximizedAboutToChange(nextMaximizeMode);
+    max_mode = nextMaximizeMode;

     // save sizes for restoring, if maximalizing
     QSizeF sz;
@@ -4040,11 +4043,11 @@
     } else {
         if (requestedQuickTileMode() == QuickTileMode(QuickTileFlag::None)) {
             QRectF savedGeometry = geometryRestore();
-            if (!(old_mode & MaximizeVertical)) {
+            if (!(currentMaximizeMode & MaximizeVertical)) {
                 savedGeometry.setTop(y());
                 savedGeometry.setHeight(sz.height());
             }
-            if (!(old_mode & MaximizeHorizontal)) {
+            if (!(currentMaximizeMode & MaximizeHorizontal)) {
                 savedGeometry.setLeft(x());
                 savedGeometry.setWidth(sz.width());
             }
@@ -4053,33 +4056,36 @@
     }

     // call into decoration update borders
-    if (isDecorated() && decoration()->window() && !(options->borderlessMaximizedWindows() && max_mode == KWin::MaximizeFull)) {
+    if (isDecorated() && decoration()->window() && !(options->borderlessMaximizedWindows() && nextMaximizeMode == KWin::MaximizeFull)) {
         changeMaximizeRecursion = true;
         const auto c = decoration()->window();
-        if ((max_mode & MaximizeVertical) != (old_mode & MaximizeVertical)) {
-            Q_EMIT c->maximizedVerticallyChanged(max_mode & MaximizeVertical);
+        if ((nextMaximizeMode & MaximizeVertical) != (currentMaximizeMode & MaximizeVertical)) {
+            Q_EMIT c->maximizedVerticallyChanged(nextMaximizeMode & MaximizeVertical);
         }
-        if ((max_mode & MaximizeHorizontal) != (old_mode & MaximizeHorizontal)) {
-            Q_EMIT c->maximizedHorizontallyChanged(max_mode & MaximizeHorizontal);
+        if ((nextMaximizeMode & MaximizeHorizontal) != (currentMaximizeMode & MaximizeHorizontal)) {
+            Q_EMIT c->maximizedHorizontallyChanged(nextMaximizeMode & MaximizeHorizontal);
         }
-        if ((max_mode == MaximizeFull) != (old_mode == MaximizeFull)) {
-            Q_EMIT c->maximizedChanged(max_mode == MaximizeFull);
+        if ((nextMaximizeMode == MaximizeFull) != (currentMaximizeMode == MaximizeFull)) {
+            Q_EMIT c->maximizedChanged(nextMaximizeMode == MaximizeFull);
+        }
+        if ((nextMaximizeMode == MaximizeShade) != (currentMaximizeMode == MaximizeShade)) {
+            Q_EMIT c->maximizedChanged(nextMaximizeMode == MaximizeShade);
         }
         changeMaximizeRecursion = false;
     }

-    if (options->borderlessMaximizedWindows()) {
+    if (nextMaximizeMode != MaximizeShade && options->borderlessMaximizedWindows()) {
         // triggers a maximize change.
         // The next setNoBorder interation will exit since there's no change but the first recursion pullutes the restore geometry
         changeMaximizeRecursion = true;
-        setNoBorder(rules()->checkNoBorder(app_noborder || (m_motif.hasDecorationsFlag() && m_motif.noDecorations()) || max_mode == MaximizeFull));
+        setNoBorder(rules()->checkNoBorder(app_noborder || (m_motif.hasDecorationsFlag() && m_motif.noDecorations()) || nextMaximizeMode == MaximizeFull));
         changeMaximizeRecursion = false;
     }

-    switch (max_mode) {
+    switch (nextMaximizeMode) {

     case MaximizeVertical: {
-        if (old_mode & MaximizeHorizontal) { // actually restoring from MaximizeFull
+        if (currentMaximizeMode & MaximizeHorizontal) { // actually restoring from MaximizeFull
             if (geometryRestore().width() == 0) {
                 // needs placement
                 const QSizeF constraintedSize = constrainFrameSize(QSizeF(width() * 2 / 3, clientArea.height()), SizeModeFixedH);
@@ -4100,7 +4106,7 @@
     }

     case MaximizeHorizontal: {
-        if (old_mode & MaximizeVertical) { // actually restoring from MaximizeFull
+        if (currentMaximizeMode & MaximizeVertical) { // actually restoring from MaximizeFull
             if (geometryRestore().height() == 0) {
                 // needs placement
                 const QSizeF constraintedSize = constrainFrameSize(QSizeF(clientArea.width(), height() * 2 / 3), SizeModeFixedW);
@@ -4123,11 +4129,11 @@
     case MaximizeRestore: {
         QRectF restore = moveResizeGeometry();
         // when only partially maximized, geom_restore may not have the other dimension remembered
-        if (old_mode & MaximizeVertical) {
+        if (currentMaximizeMode & MaximizeVertical) {
             restore.setTop(geometryRestore().top());
             restore.setBottom(geometryRestore().bottom());
         }
-        if (old_mode & MaximizeHorizontal) {
+        if (currentMaximizeMode & MaximizeHorizontal) {
             restore.setLeft(geometryRestore().left());
             restore.setRight(geometryRestore().right());
         }
@@ -4173,6 +4179,11 @@
         break;
     }

+    case MaximizeShade: {
+        moveResize(QRectF(geometryRestore().x(), geometryRestore().y(), geometryRestore().width(), 24));
+        break;
+    }
+
     case MaximizeFull: {
         moveResize(clientArea);
         exitQuickTileMode();
@@ -4189,7 +4200,7 @@
     updateAllowedActions();
     updateWindowRules(Rules::MaximizeVert | Rules::MaximizeHoriz | Rules::Position | Rules::Size);

-    if (max_mode != old_mode) {
+    if (nextMaximizeMode != currentMaximizeMode) {
         Q_EMIT maximizedChanged();
     }
 }
Index: src/xdgshellwindow.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/xdgshellwindow.cpp b/src/xdgshellwindow.cpp
--- a/src/xdgshellwindow.cpp	(revision 9739e3174abaaa97a3008f6933af4642bc26b800)
+++ b/src/xdgshellwindow.cpp	(revision f9fae66c0b4be8f6ca8f383fcd823190d7dd0143)
@@ -835,20 +835,52 @@
     scheduleConfigure();
 }

-void XdgToplevelWindow::doSetMaximized()
+/*
+    Inflict a difference between `m_acknowledgedStates` and `m_nextStates` so that, a delta can be observed when the
+    two members are compared
+*/
+void XdgToplevelWindow::doSetMaximized(MaximizeMode nextMaximizeMode, MaximizeMode currentMaximizeMode)
 {
-    if (requestedMaximizeMode() & MaximizeHorizontal) {
-        m_nextStates |= XdgToplevelInterface::State::MaximizedHorizontal;
+    /*
+        Prepare `m_nextStates`
+        since the shade state leaches off the maximization mechanism, `m_nextStates` needs to be compensated so that,
+        the delta will correctly reflect the need to maximize
+    */
+    if (nextMaximizeMode == MaximizeShade) {
+        m_nextStates |= XdgToplevelInterface::State::Shaded;
     } else {
-        m_nextStates &= ~XdgToplevelInterface::State::MaximizedHorizontal;
-    }
+        m_nextStates &= ~XdgToplevelInterface::State::Shaded;
+
+        if (nextMaximizeMode & MaximizeHorizontal) {
+            m_nextStates |= XdgToplevelInterface::State::MaximizedHorizontal;
+        }

-    if (requestedMaximizeMode() & MaximizeVertical) {
-        m_nextStates |= XdgToplevelInterface::State::MaximizedVertical;
-    } else {
-        m_nextStates &= ~XdgToplevelInterface::State::MaximizedVertical;
+        if (nextMaximizeMode & MaximizeVertical) {
+            m_nextStates |= XdgToplevelInterface::State::MaximizedVertical;
+        }
+    }
+
+    /*
+        Prepare `m_acknowledgedStates`
+        since the shade state leaches off the maximization mechanism, `m_acknowledgedStates` needs to be compensated
+        so that, the delta will correctly reflect the need to maximize
+    */
+
+    // if the transition is to go from MaximizeShade to MaximizeFull
+    if (currentMaximizeMode == MaximizeShade && nextMaximizeMode == MaximizeFull) {
+        // then unset the shade bits to ensure the delta will reflect change in maximization
+        m_acknowledgedStates &= ~XdgToplevelInterface::State::Shaded;
     }

+    // if the transition is to go from MaximizeFull to MaximizeShade
+    if (currentMaximizeMode == MaximizeFull && nextMaximizeMode == MaximizeShade) {
+        // then unset the maximize bits to ensure the delta will reflect change in shading
+        m_acknowledgedStates &= ~XdgToplevelInterface::State::Maximized;
+    }
+
+    /*
+        Schedule comparison between `m_acknowledgedStates` and `m_nextStates`
+    */
     scheduleConfigure();
 }

@@ -1034,7 +1066,10 @@
 {
     const XdgToplevelInterface::States delta = m_acknowledgedStates ^ states;

-    if (delta & XdgToplevelInterface::State::Maximized) {
+    if (states & (XdgToplevelInterface::State::Shaded & ~XdgToplevelInterface::State::Maximized)) {
+        updateMaximizeMode(MaximizeShade);
+    }
+    else if (delta & XdgToplevelInterface::State::Maximized) {
         MaximizeMode maximizeMode = MaximizeRestore;
         if (states & XdgToplevelInterface::State::MaximizedHorizontal) {
             maximizeMode = MaximizeMode(maximizeMode | MaximizeHorizontal);
@@ -1679,8 +1714,64 @@
     doSetFullScreen();
 }

+void XdgToplevelWindow::setNextMaximizeHorizontalGeometry(QRectF &nextGeometry, const QRectF &clientArea, MaximizeMode nextMaximizeMode)
+{
+    // if the window is to be maximized
+    if (nextMaximizeMode & MaximizeHorizontal && nextMaximizeMode != MaximizeShade) {
+        // then take the full view port width
+        nextGeometry.setX(clientArea.x());
+        nextGeometry.setWidth(clientArea.width());
+        return;
+    }
+
+    QRectF previousGeometry = geometryRestore();
+
+    if (!previousGeometry.isValid()) {
+        nextGeometry.setX(clientArea.x());
+        nextGeometry.setWidth(0);
+        return;
+    }
+
+    // if the window is to be shaded or restored,
+    // then restore
+    nextGeometry.setX(previousGeometry.x());
+    nextGeometry.setWidth(previousGeometry.width());
+}
+
+void XdgToplevelWindow::setNextMaximizeVerticalGeometry(QRectF &nextGeometry, const QRectF &clientArea, MaximizeMode nextMaximizeMode)
+{
+    // if the window is to be maximized
+    if (nextMaximizeMode & MaximizeVertical && nextMaximizeMode != MaximizeShade) {
+        // then take the full view port height
+        nextGeometry.setY(clientArea.y());
+        nextGeometry.setHeight(clientArea.height());
+        return;
+    }
+
+    QRectF previousGeometry = geometryRestore();
+
+    if (!previousGeometry.isValid()) {
+        nextGeometry.setY(clientArea.y());
+        nextGeometry.setHeight(0);
+        return;
+    }
+
+    // if the window is to be shaded
+    if (nextMaximizeMode & MaximizeVertical && nextMaximizeMode == MaximizeShade) {
+        // then shrink to the window title bar height
+        nextGeometry.setY(previousGeometry.y());
+        nextGeometry.setHeight(24);
+        return;
+    }
+
+    // if the window is to be restored,
+    // then restore
+    nextGeometry.setY(previousGeometry.y());
+    nextGeometry.setHeight(previousGeometry.height());
+}
+
 static bool changeMaximizeRecursion = false;
-void XdgToplevelWindow::maximize(MaximizeMode mode, const QRectF &restore)
+void XdgToplevelWindow::maximize(MaximizeMode nextMaximizeMode, const QRectF &restore)
 {
     if (changeMaximizeRecursion) {
         return;
@@ -1692,35 +1783,43 @@

     const QRectF clientArea = isElectricBorderMaximizing() ? workspace()->clientArea(MaximizeArea, this, interactiveMoveResizeAnchor()) : workspace()->clientArea(MaximizeArea, this, moveResizeOutput());

-    const MaximizeMode oldMode = m_requestedMaximizeMode;
+    const MaximizeMode currentMaximizeMode = m_requestedMaximizeMode;
     const QRectF oldGeometry = moveResizeGeometry();

-    mode = rules()->checkMaximize(mode);
-    if (m_requestedMaximizeMode == mode) {
+    if (nextMaximizeMode != MaximizeShade) {
+        nextMaximizeMode = rules()->checkMaximize(nextMaximizeMode);
+    }
+
+    if (currentMaximizeMode == nextMaximizeMode) {
         return;
     }

-    Q_EMIT maximizedAboutToChange(mode);
-    m_requestedMaximizeMode = mode;
+    Q_EMIT maximizedAboutToChange(nextMaximizeMode);
+
+    // backup the next maximize mode (it will become the currentMaximizeMode in the next round)
+    m_requestedMaximizeMode = nextMaximizeMode;

     // call into decoration update borders
-    if (m_nextDecoration && !(options->borderlessMaximizedWindows() && m_requestedMaximizeMode == MaximizeFull)) {
+    if (m_nextDecoration && !(options->borderlessMaximizedWindows() && nextMaximizeMode == MaximizeFull)) {
         changeMaximizeRecursion = true;
         const auto c = m_nextDecoration->window();
-        if ((m_requestedMaximizeMode & MaximizeVertical) != (oldMode & MaximizeVertical)) {
-            Q_EMIT c->maximizedVerticallyChanged(m_requestedMaximizeMode & MaximizeVertical);
+        if ((nextMaximizeMode & MaximizeVertical) != (currentMaximizeMode & MaximizeVertical)) {
+            Q_EMIT c->maximizedVerticallyChanged(nextMaximizeMode & MaximizeVertical);
         }
-        if ((m_requestedMaximizeMode & MaximizeHorizontal) != (oldMode & MaximizeHorizontal)) {
-            Q_EMIT c->maximizedHorizontallyChanged(m_requestedMaximizeMode & MaximizeHorizontal);
+        if ((nextMaximizeMode & MaximizeHorizontal) != (currentMaximizeMode & MaximizeHorizontal)) {
+            Q_EMIT c->maximizedHorizontallyChanged(nextMaximizeMode & MaximizeHorizontal);
         }
-        if ((m_requestedMaximizeMode == MaximizeFull) != (oldMode == MaximizeFull)) {
-            Q_EMIT c->maximizedChanged(m_requestedMaximizeMode == MaximizeFull);
+        if ((nextMaximizeMode == MaximizeFull) != (currentMaximizeMode == MaximizeFull)) {
+            Q_EMIT c->maximizedChanged(nextMaximizeMode == MaximizeFull);
+        }
+        if ((nextMaximizeMode == MaximizeShade) != (currentMaximizeMode == MaximizeShade)) {
+            Q_EMIT c->maximizedChanged(nextMaximizeMode == MaximizeShade);
         }
         changeMaximizeRecursion = false;
     }

-    if (options->borderlessMaximizedWindows()) {
-        setNoBorder(m_requestedMaximizeMode == MaximizeFull);
+    if (nextMaximizeMode != MaximizeShade && options->borderlessMaximizedWindows()) {
+        setNoBorder(nextMaximizeMode == MaximizeFull);
     }

     if (!restore.isNull()) {
@@ -1728,11 +1827,11 @@
     } else {
         if (requestedQuickTileMode() == QuickTileMode(QuickTileFlag::None)) {
             QRectF savedGeometry = geometryRestore();
-            if (!(oldMode & MaximizeVertical)) {
+            if (!(currentMaximizeMode & MaximizeVertical)) {
                 savedGeometry.setTop(oldGeometry.top());
                 savedGeometry.setBottom(oldGeometry.bottom());
             }
-            if (!(oldMode & MaximizeHorizontal)) {
+            if (!(currentMaximizeMode & MaximizeHorizontal)) {
                 savedGeometry.setLeft(oldGeometry.left());
                 savedGeometry.setRight(oldGeometry.right());
             }
@@ -1740,52 +1839,19 @@
         }
     }

-    if (m_requestedMaximizeMode != MaximizeRestore) {
+    if (nextMaximizeMode != MaximizeRestore) {
         exitQuickTileMode();
     }

-    QRectF geometry = oldGeometry;
-
-    if (m_requestedMaximizeMode & MaximizeHorizontal) {
-        // Stretch the window vertically to fit the size of the maximize area.
-        geometry.setX(clientArea.x());
-        geometry.setWidth(clientArea.width());
-    } else if (oldMode & MaximizeHorizontal) {
-        if (geometryRestore().isValid()) {
-            // The window is no longer maximized horizontally and the saved geometry is valid.
-            geometry.setX(geometryRestore().x());
-            geometry.setWidth(geometryRestore().width());
-        } else {
-            // The window is no longer maximized horizontally and the saved geometry is
-            // invalid. This would happen if the window had been mapped in the maximized state.
-            // We ask the client to resize the window horizontally to its preferred size.
-            geometry.setX(clientArea.x());
-            geometry.setWidth(0);
-        }
-    }
+    QRectF nextMaximizeGeometry = oldGeometry;
+    setNextMaximizeHorizontalGeometry(nextMaximizeGeometry, clientArea, nextMaximizeMode);
+    setNextMaximizeVerticalGeometry(nextMaximizeGeometry, clientArea, nextMaximizeMode);

-    if (m_requestedMaximizeMode & MaximizeVertical) {
-        // Stretch the window horizontally to fit the size of the maximize area.
-        geometry.setY(clientArea.y());
-        geometry.setHeight(clientArea.height());
-    } else if (oldMode & MaximizeVertical) {
-        if (geometryRestore().isValid()) {
-            // The window is no longer maximized vertically and the saved geometry is valid.
-            geometry.setY(geometryRestore().y());
-            geometry.setHeight(geometryRestore().height());
-        } else {
-            // The window is no longer maximized vertically and the saved geometry is
-            // invalid. This would happen if the window had been mapped in the maximized state.
-            // We ask the client to resize the window vertically to its preferred size.
-            geometry.setY(clientArea.y());
-            geometry.setHeight(0);
-        }
-    }
-
-    moveResize(geometry);
+    // emit signal to resize window
+    moveResize(nextMaximizeGeometry);
     markAsPlaced();

-    doSetMaximized();
+    doSetMaximized(nextMaximizeMode, currentMaximizeMode);
 }

 XdgPopupWindow::XdgPopupWindow(XdgPopupInterface *shellSurface)
Index: src/xdgshellwindow.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/xdgshellwindow.h b/src/xdgshellwindow.h
--- a/src/xdgshellwindow.h	(revision 9739e3174abaaa97a3008f6933af4642bc26b800)
+++ b/src/xdgshellwindow.h	(revision f9fae66c0b4be8f6ca8f383fcd823190d7dd0143)
@@ -163,6 +163,8 @@
     bool wantsInput() const override;
     void setFullScreen(bool set) override;
     void closeWindow() override;
+    void setNextMaximizeHorizontalGeometry(QRectF &nextGeometry, const QRectF &clientArea, MaximizeMode nextMaximizeMode);
+    void setNextMaximizeVerticalGeometry(QRectF &nextGeometry, const QRectF &clientArea, MaximizeMode nextMaximizeMode);
     void maximize(MaximizeMode mode, const QRectF &restore = QRectF()) override;

     void installAppMenu(AppMenuInterface *appMenu);
@@ -179,7 +181,7 @@
     void doMinimize() override;
     void doSetActive() override;
     void doSetFullScreen();
-    void doSetMaximized();
+    void doSetMaximized(MaximizeMode nextMaximizeMode, MaximizeMode currentMaximizeMode);
     bool doStartInteractiveMoveResize() override;
     void doFinishInteractiveMoveResize() override;
     bool acceptsFocus() const override;
